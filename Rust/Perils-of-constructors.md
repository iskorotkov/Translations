Опасности конструкторов
Aleksey Kladov
https://matklad.github.io/2019/07/16/perils-of-constructors.html

Один из моих любимых блогов о Rust -  [Things Rust Shipped Without авторства Graydon Hoare](https://graydon2.dreamwidth.org/218040.html). Для меня любая способная выстрелить в ногу фича, отсутствующая в языке, обычно важнее выразительности. В этом слегка философском эссе я хочу поговорить о моей особенно любимой фиче, отсутствующей в Rust - о конструкторах.

# Что такое конструктор?

Конструкторы обычно используются в ОО языках. Задача конструктора - полностью инициализировать объект, прежде чем остальной мир увидит его. На первый взгляд, это кажется действительно хорошей идеей:

1. Вы **устанавливаете инварианты** в конструкторе.
2. Каждый метод заботится о **сохранении** инвариантов.
3. Вместе эти два свойства значат, что можно думать об объектах как об инвариантах, а не как о конкретных внутренних состояниях.

Конструктор здесь играет роль индукционной базы, будучи единственным способом создать новый объект.

К сожалению, в этих рассуждениях есть дыра: сам конструктор наблюдает объект в незаконченном состоянии, что и создает множество проблем.

# Значение this

Когда конструктор инициализирует объект, он начинает с некоторого пустого состояния. Но как вы определите это пустое состояние для произвольного объекта?

Наиболее легкий способ сделать это - присвоить всем полям значения по умолчанию: false для bool, 0 для чисел, null для всех ссылок. Но такой подход требует, чтобы все типы имели значения по умолчанию, и вводит в язык печально известный null. Именно по этому пути пошла Java: в начале создания объекта все поля имеют значения 0 или null.

При таком подходе будет очень сложно избавиться от null впоследствии. Хороший пример - Kotlin. Kotlin использует non-nullable типы по умолчанию, но он вынужден работать с прежде существующей семантикой JVM. Дизайн языка хорошо скрывает этот факт и хорошо применим на практике, но **несостоятелен**. То есть, используя конструкторы, возможно обойти проверки на null в Kotlin.

Главная уловка Kotlin - поощрять так называемые "первичные конструкторы", которые **одновременно** объявляют поле и присваивают ему значения прежде, чем будет выполняться какой-либо пользовательский код:

```kotlin
class Person(
  val firstName: String,
  val lastName: String
) { ... }
```

Другой вариант: если поле не объявлено в конструкторе, программист должен немедленно инициализировать его:

```kotlin
class Person(val firstName: String, val lastName: String) {
    val fullName: String = "$firstName $lastName"
}
```

Попытка использовать поле перед инициализацией запрещена статически по принципу максимальных усилий:

```kotlin
class Person(val firstName: String, val lastName: String) {
    val fullName: String
    init {
        println(fullName) // ошибка: переменная должна быть инициализирована
        fullName = "$firstName $lastName"
    }
}
```

Но, имея немного креативности, любой может обойти эти проверки. Например, для этого подойдет вызов метода:

```kotlin
class A {
    val x: Any
    init {
        observeNull()
        x = 92
    }
    fun observeNull() = println(x) // выводит null
}

fun main() {
    A()
}
```

Также захват this лямбдой (которая создается в Kotlin следующим образом: { args -> body }):

```kotlin
class B {
    val x: Any = { y }()
    val y: Any = x
}

fun main() {
    println(B().x) // выводит null
}
```

Примеры вроде этих кажутся нереальными в действительности (и так и есть), но я находил подобные ошибки в реальном коде (правило вероятности 0-1 Колмогорова в разработке ПО: в достаточно большой базе любой кусок кода почти гарантированно существует, по крайней мере, если не запрещен статически компилятором; в таком случае он почти точно не существует).

Причина, по которой Kotlin может существовать с этой несостоятельностью, та же, что и в случае с ковариантными массивами в Java: в любом случае в рантайме все равно происходят проверки. В конце концов, я бы не хотел усложнять систему типов Kotlin, чтобы сделать вышеприведенные случаи некорректными на этапе компиляции: учитывая существующие ограничения (семантику JVM), отношение цена/польза проверок в рантайме намного больше таковой у статических проверок.

А что если язык не имеет разумного значения по умолчанию для каждого типа? Например, в C++, где определенные пользователем типы не обязательно являются ссылками, вы не можете просто присвоить null каждому полю и сказать, что это будет работать! Вместо этого в C++ используется специальный синтаксис для установления начальных значений полям: списки инициализации:

```cpp
#include <string>
#include <utility>

class person {
  person(std::string first_name, std::string last_name)
    : first_name(std::move(first_name))
    , last_name(std::move(last_name))
  {}

  std::string first_name;
  std::string last_name;
};
```

Так как это специальный синтаксис, остальная часть языка не работает с ним безупречно. Например, сложно поместить в списки инициализации произвольные операции, так как C++ не является фразированным языком (expression-oriented language) (что само по себе нормально). Чтобы работать с исключениями, возникающими с списках инициализации, необходимо использовать еще одну [невразумительную фичу языка](https://en.cppreference.com/w/cpp/language/function-try-block).

# Вызов методов из конструктора
