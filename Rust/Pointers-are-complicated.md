Указатели сложны, или Что хранится в байте?
Ralf Jung
https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html

Этим летом я снова работаю над Rust фуллтайм, и я снова буду работать (помимо прочих вещей) над "моделью памяти" для Rust/MIR. Однако, прежде чем я заговорю о своих идеях, я наконец должен развеять миф, что "указатели просты: они являются простыми числами". Обе части этого утверждения ошибочны, по крайней мере в языках с небезопасными фичами, таких как Rust или C: указатели нельзя назвать ни простыми, ни (обычными) числами.

Я бы также хотел обсудить часть модели памяти, которую необходимо затронуть, прежде чем мы можем говорить о более сложных частях: в *какой форме* данные хранятся в памяти? Память состоит из байтов, минимальных адресуемых единиц и наименьших элементов, к которым можно получить доступ (по крайней мере на большинстве платформ), но каковы возможные значения байта? Опять же, оказывается, что "
то просто 8-битное число" не подходит в качестве ответа.

Я надеюсь, что прочитав этот пост, вы согласитесь со мной относительно обоих утверждений.

# Указатели сложны

В чем проблема с "указатели - это обычные числа"? Давайте рассмотрим следующий пример: (я использую C++ здесь, так как писать небезопасный код в C++ проще, чем в Rust, и небезопасный код - это как раз то место, где и появляются проблемы. Небезопасный Rust и C имеет все те же проблемы, что и C++).

```cpp
int test() {
    auto x = new int[8];
    auto y = new int[8];
    y[0] = 42;
    int i = /* какие-то вычисления без побочных эффектов */;
    auto x_ptr = &x[i];
    *x_ptr = 23;
    return y[0];
}
```

Оптимизация последнего чтения y[0] с возвращением всегда 42 очень выгодна. Обоснование такой оптимизации - изменение x_ptr, которое указывает на x, не может изменить y.

Однако, имея дело с языками низкого уровня, такими как C++, мы можем нарушить это предположение, присвоив i значение y-x. Так как &x[i] - это то же самое, что и x+i, мы записываем 23 в &y[0].

Конечно, это не мешает C++ компиляторам делать такие оптимизации. Чтобы разрешить это, стандарт говорит, что наш код имеет [UB](https://www.ralfj.de/blog/2017/07/14/undefined-behavior.html).

Во-первых, не разрешается выполнять арифметические операции над указателями (как в случае с &x[i]), если в этом случае указатель [выходит за любую из границ массива](https://timsong-cpp.github.io/cppwp/n4140/expr.add#5). Наша программа нарушает это правило: x[i] выходит за границы x, поэтому это является UB. Иными словами, даже *вычисление* значения x_ptr является UB, так что мы даже не доходим до того места, где мы хотим *использовать* этот указатель.

(Оказывается, i = y-x также является UB, так как [разрешается вычитать только указатели, указывающие в место одного выделения памяти](https://timsong-cpp.github.io/cppwp/n4140/expr.add#6). Однако мы могли бы написать i = ((size_t)y - (size_t)x)/sizeof(int), чтобы обойти это ограничение.)

Но мы еще не закончили: это правило имеет единственное исключение, которое мы можем использовать в нашу пользу. Если арифметическая операция вычисляет значение указателя на адрес *точно после* конца массива, то все в порядке. (Это исключение необходимо для вычисления vec.end() для самых обычных циклов в C++98.)

Давайте немного изменим пример:

```cpp
int test() {
    auto x = new int[8];
    auto y = new int[8];
    y[0] = 42;
    auto x_ptr = x+8; // элемент после конца
    if (x_ptr == &y[0])
      *x_ptr = 23;
    return y[0];
}
```

А теперь представьте, что x и y были выделены *друг за другом*, причем y имеет больший адрес. Тогда x_ptr указывает *на начало* y! Тогда условие истинно и присваивание происходит. При этом тут нет UB из-за выхода указателя за границы.

Кажется, что это не позволит провести оптимизацию. Однако стандарт C++ имеет другой туз в рукаве, чтобы помочь создателям компиляторов: на самом деле он не позволяет нам использовать x_ptr. Согласно тому, что говорится в стандарте про [прибавление чисел к указателям](https://timsong-cpp.github.io/cppwp/n4140/expr.add#5), x_ptr указывает на адрес после последнего элемента массива. Он *не* указывает на конкретный элемент другого объекта, *даже если они имеют одинаковый адрес*. (По крайней мере это распространенная интерпретация стандарта, на основе которой [LLVM оптимизирует этот код](https://godbolt.org/g/vxmtej).)

И даже несмотря на то, что x_ptr и &y[0] указывают на один *адрес*, это не делает их *одинаковым указателем*, то есть они не могут быть использованы взаимозаменяемо: &y[0] указывает на первый элемент y; x_ptr указывает на адрес после x. Если мы заменим *x_ptr = 23 строкой *&y[0] = 0, мы изменим значение программы, даже несмотря на то, что два указателя проверялись на равенство.

Это стоит повторить:

> То, что два указателя указывают на один адрес, не значит то, что они равны и могут быть использованы взаимозаменяемо.

Да, эта разница трудноуловима. На самом деле, это до сих пор вызывает различия в программах, скомпилированных с LLVM и GCC.

Также заметьте, что это правило "адрес после" - не единственное место в C/C++, где мы можем наблюдать такой эффект. Другой пример - ключевое слово restrict в C, которое может быть использовано для выражения того, что указатели не перекрываются (не равны):

```c
int foo(int *restrict x, int *restrict y) {
    *x = 42;
    if (x == y) {
        *y = 23;
    }
    return *x;
}

int test() {
    int x;
    return foo(&x, &x);
}
```

Вызов test() вызывает UB, так как два доступа к памяти в foo не должны происходить к одному адресу. Заменив *y на *x в foo, мы изменив значение программы, и она больше не будет вызывать UB. Еще раз: несмотря на то, что x и y имеют один адрес, их нельзя использовать взаимозаменяемо.

Указатели - это определенно не простые числа.

# Простая модель указателей

Так что такое указатель? Я не знаю полный ответ. На самом деле, это открытая область исследований.

Один важный момент: здесь мы рассматриваем *абстрактную модель* указателей. Безусловно, на настоящем комьютере указатели являются числами. Но настоящий компьютер не проводит те оптимизации, которые делают современные компиляторы C++. Если бы мы написали вышеприведенные программы на ассемблере, то там не было бы ни UB, ни оптимизаций. C++ и Rust применяют более "высокоуровневый" подход к памяти и указателям, ограничивая программиста в угоду компилятору. Когда требуется формально описать, что программист может и не может делать в этих языках, модель указателей как чисел разбивается вдребезги, так что нам нужно найти что-то еще. Это другой пример использования "виртуальной машины", отличающейся от реального компьютера в целях спецификации - идее, о которой [я писал раньше](https://www.ralfj.de/blog/2017/06/06/MIR-semantics.html).

Вот простое предложение (на самом деле эта модель указателей используется в [CompCert](https://hal.inria.fr/hal-00703441/document) и [моей работе RustBelt](https://www.ralfj.de/blog/2017/07/08/rustbelt.html), а также способ, согласно которому [miri](https://github.com/solson/miri/) реализует [указатели](https://github.com/rust-lang/rust/blob/fefe81605d6111faa8dbb3635ab2c51d59de740a/src/librustc/mir/interpret/mod.rs#L121-L124)): указатель - это пара какого-то ID, однозначно определяющего область памяти (allocation), и смещение относительно этой области. Если написать это на Rust:

```rust
struct Pointer {
    alloc_id: usize,
    offset: isize,
}
```

Операции добавления (вычитания) числа к указателю (из указателя) влияют только на смещение, и поэтому указатель никогда не может покинуть область памяти. Вычитание указателей возможно только в том случае, если они относятся к одной области памяти (в соответствии с [C++](https://timsong-cpp.github.io/cppwp/n4140/expr.add#6)).

(Как мы могли видеть, стандарт C++ применяет эти правила к массивам, а не областям памяти. Однако, LLVM применяет их на [уровне областей](https://llvm.org/docs/LangRef.html#getelementptr-instruction).)

Оказывается (и miri показывает то же самое), что эта модель может хорошо послужить нам. Мы всегда помним, к какой области памяти относится указатель, поэтому мы можем отличить указатель "один после" одной области памяти от указателя на начало другой области. Таким образом miri может обнаружить, что наш второй пример (с &x[8]) имеет UB.

# Наша модель разваливается на куски


